class SISP
types
	public	Date :: year : nat
									month: nat
									day : nat;
	public String = seq of char;
	
	public Path = seq of Author;

instance variables
	private publications : set of Publication;
	private authors : set of Author;

operations

	public SISP: () ==> SISP
		SISP() ==
		(
			publications:={};
			authors:={};
		);

	public addAuthor : Author ==> ()
		addAuthor(elem) ==
			authors := authors union {elem}
		pre elem not in set authors
		post elem in set authors;
	
	public pure getAuthors : () ==> set of Author
		getAuthors() ==
			return authors;
	
	public addPublication : Publication ==> ()
		addPublication(elem) ==
			publications := publications union {elem}
		pre elem not in set publications
		post elem in set publications;

	public pure conected : seq of Author ==> bool
	conected(a) == 
		if(len a = 1 )
		then return true
		else return conected(tl a) and ((hd a).getPublications() inter (hd tl a).getPublications() <> {});


	public pure getCoAuthorPath : Author * Author ==> Path
		getCoAuthorPath (source,target) == 
			(
				dcl Q:seq of Author := [];
				dcl dist:map Author to int := { |-> };
				dcl prev:map Author to [Author] := { |-> };
				for all a in set authors do
				(
					dist := dist ++ {a |-> card authors};
					prev := prev ++ {a |-> nil};
					Q:=Q ^ [a];
				);
				dist(source):=0;
				while len Q <> 0 do
				(
					dcl u:Author;
					u:=lowestDistance(Q,dist);
					if u = target
					then
					(
						dcl path:Path :=[];
						while prev(u) <> nil do
						(
							path:=[u]^path;
							u:=prev(u);
						);
						path:=[u]^path;
						return path;
					);
					Q:=remove(Q,u);
					for all v in set authors do
					(
						if u.coAuthed(v)
						then
						(
							dcl alt:int;
							alt:=dist(u)+1;
							if alt < dist(v)
							then
							(
								dist(v) := alt;
								prev(v) := u;
							);
						);
					);
				);
				return []
			)
		pre source <> target;
		
	pure remove : (seq of Author) * Author ==> seq of Author
		remove (k,z) ==
			(dcl nk : seq of Author := [];
			for elem in k do
				if elem <> z
				then nk := nk^[elem];
			return nk
			);
			
	pure lowestDistance: (seq of Author) * (map Author to int) ==> Author
		lowestDistance(Q,dist) ==
		(
			dcl min:Author;
			min := hd Q;
			for all a in set elems Q do
			(
				if dist(a) < dist(min)
				then min:=a
			);
			return min;
		);
			
functions

	
end SISP