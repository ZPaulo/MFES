class SISP
types
	public	Date :: year : nat
									month: nat
									day : nat;
	public String = seq of char;
	
	public Path = seq of Author;

instance variables
	private authors : set of Author;

operations

	public SISP: () ==> SISP
		SISP() ==
		(
			authors:={};
		);

	public addAuthor : Author ==> ()
		addAuthor(elem) ==
			authors := authors union {elem}
		pre elem not in set authors
		post elem in set authors;
	
	public pure getCoAuthorPath : Author * Author ==> Path
		getCoAuthorPath (source,target) == 
			(
				dcl Q:seq of Author := [];
				dcl dist:map Author to int := { |-> };
				dcl prev:map Author to [Author] := { |-> };
				for all a in set authors do
				(
					dist := dist ++ {a |-> card authors};
					prev := prev ++ {a |-> nil};
					Q:=Q ^ [a];
				);
				dist(source):=0;
				while len Q <> 0 do
				(
					dcl u:Author;
					u:= hd Q;--Distance between co authors is always 1 so there is no point is seeking a minimum
					if u = target and prev(u) <> nil
					then
					(
						dcl path:Path :=[];
						while prev(u) <> nil do
						(
							path:=[u]^path;
							u:=prev(u);
						);
						path:=[u]^path;
						return path;
					);
					Q:=remove(Q,u);
					for all v in set authors do
					(
						if u.coAuthed(v)
						then
						(
							dcl alt:int;
							alt:=dist(u)+1;
							if alt < dist(v)
							then
							(
								dist(v) := alt;
								prev(v) := u;
							);
						);
					);
				);
				return []
			)
		pre source <> target;
		
	pure remove : (seq of Author) * Author ==> seq of Author
		remove (k,z) ==
			(dcl nk : seq of Author := [];
			for elem in k do
				if elem <> z
				then nk := nk^[elem];
			return nk
			);
			
	pure public getErdosNumber : Author * Author ==> int
		getErdosNumber (s,t) ==
		(
			return len getCoAuthorPath(s,t);
		)
			
functions

	
end SISP