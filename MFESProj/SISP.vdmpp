class SISP
types
	public	Date :: year : nat
									month: nat
									day : nat;
	public String = seq of char;
	
	public Path = seq of Author;

instance variables
	private publications : set of Publication;
	private authors : set of Author;

operations

	public SISP: () ==> SISP
		SISP() ==
		(
			publications:={};
			authors:={};
		);

	public addAuthor : Author ==> ()
		addAuthor(elem) ==
			authors := authors union {elem}
		pre elem not in set authors
		post elem in set authors;
	
	public pure getAuthors : () ==> set of Author
		getAuthors() ==
			return authors;
	
	public addPublication : Publication ==> ()
		addPublication(elem) ==
			publications := publications union {elem}
		pre elem not in set publications
		post elem in set publications;

	public pure conected : seq of Author ==> bool
	conected(a) == 
		if(len a = 1 )
		then return true
		else return conected(tl a) and ((hd a).getPublications() inter (hd tl a).getPublications() <> {});

	--TODO forall 
	public pure getCoAuthorPath : Author * Author ==> Path
		getCoAuthorPath (a1,a2) == 
			(
				dcl path:Path;
				dcl Q:set of Author;
				dcl dist:map Author to int;
				dcl prev:map Author to int;
				for all a in set authors do
				(
					dist := dist ++ {a |-> card authors};
					prev := prev ++ {a |-> null};
					Q:=Q union {a};
				);
				return []
			)
		pre a1 <> a2;
			

	
end SISP